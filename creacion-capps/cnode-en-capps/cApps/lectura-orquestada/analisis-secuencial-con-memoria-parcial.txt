# CNode: capps/lo4q-an-seq (Lectura Orquestada 4Q — Análisis Secuencial con Memoria Parcial) @1.1.0
# Propósito: Ejecutar un intake por pasos (IMG+Proyecto → P2 → P3 → P4), almacenar MEMORIAS PARCIALES por paso
# y, solo cuando todas estén completas, sintetizar un único "code snippet txt" canónico por proyecto.

id: "cnode:capps/lo4q-an-seq@1.1.0"
title: "cApp: Lectura Orquestada 4Q — Análisis Secuencial (LO4Q-AN-SEQ)"
version: "1.1.0"
owner: "usuario"
license: "internal-use"
status: "stable"

# ---------- CONTEXTO ----------
context:
  problem: >
    Existen varios proyectos (A, B, C, D, …) con respuestas previas a las preguntas P2–P4 (P1 = P2 por diseño) y un set de imágenes.
    Se requiere un flujo SECUENCIAL que pida y analice cada insumo por turno, guardando memorias parciales y evitando producir
    salidas incompletas si faltan entradas.
  intent: >
    Orquestar, por proyecto, la recolección paso a paso de: [IMG]+[PROYECTO], luego [P2], luego [P3], luego [P4]; almacenar una memoria
    parcial tras cada paso; y generar una síntesis final canónica solo si las cuatro memorias existen.
  success_criteria:
    - "El sistema nunca pide más de un insumo a la vez."
    - "Cada entrega produce una MEMORIA PARCIAL etiquetada: [IMG], [P2], [P3], [P4]."
    - "La síntesis se bloquea hasta completar las cuatro memorias requeridas."
    - "El snippet final es canónico y comparable entre proyectos."
  non_goals:
    - "No re-ejecutar el flujo original de preguntas ni inventar contenido."
    - "No modificar archivos del usuario."

# ---------- INTERFAZ (EXPORT SURFACE) ----------
provides:
  - name: "lo4q-an-seq.snippet"
    version: "1.0.0"
    types_used: ["ProjectSynopsis"]
    description: "Un code snippet txt por proyecto con entendimiento consolidado, basado en memorias parciales IMG/P2/P3/P4."
requires:
  - name: "user.step_inputs"
    version_range: ">=1.0.0"
    types_expected: ["ProjectName","Array<Image>|'sin imágenes'","AnswerP2","AnswerP3","AnswerP4"]
    optional: false
  - name: "chat.context"
    version_range: ">=1.0.0"
    types_expected: ["ProjectContext"]
    optional: true

types:
  ProjectName: { format: "string", min_length: 1 }
  Image: { mime: ["image/png","image/jpeg","image/webp"] }
  AnswerP2: { format: "text/plain", min_words: 50, describes: "definición + objetivo central + alcance (qué sí/qué no)" }
  AnswerP3: { format: "text/plain", min_words: 50, describes: "flujo de trabajo que debe seguir la cApp en este proyecto" }
  AnswerP4: { format: "text/plain", min_words: 50, describes: "punto de vista y reencuadre al proyecto/chat actual" }
  ProjectContext: { fields: ["prompt_global?:string","archivos_de_proyecto?:string[]"] }
  MemoryPartial:
    fields: [ "project", "kind('IMG'|'P2'|'P3'|'P4')", "payload", "hash", "timestamp" ]
  ProjectSynopsis:
    fields:
      - title: "string"
      - project: "string"
      - summary: "string"
      - structure_components: "string"
      - deep_selfcontained: "string"
      - reframing_current_project: "string"
      - assumptions_limits: "string"
      - risks_open_questions: "string"
      - glossary_aliases: "string"
      - provenance: "string"

# ---------- POLÍTICAS E INVARIANTES ----------
policies:
  evidence_only: true
  deterministic: true
  provenance: true
  merge_policy:
    upsert_only: true
    conflict: "prefer-specificity"
    id_collision: "namespaced-rename"
    provenance: "record"
invariants:
  - "P1 no se solicita porque P1 = P2."
  - "En cada paso se pide un único insumo. No se aceptan paquetes múltiples."
  - "Cada memoria parcial queda asociada a {project} y a su KIND (IMG/P2/P3/P4)."
  - "El snippet final no se emite si falta alguna memoria parcial."
fitness_tests:
  - name: "memorias_completas"
    check: "exists(MEM[IMG]) AND exists(MEM[P2]) AND exists(MEM[P3]) AND exists(MEM[P4])"
  - name: "longitud_minima_respuestas"
    check: "words(P2)>=50 AND words(P3)>=50 AND words(P4)>=50"
  - name: "provenance_por_seccion"
    check: "todas las secciones del snippet llevan etiquetas [IMG]/[P2]/[P3]/[P4] donde aplique"
  - name: "punto_de_vista_explicito"
    check: "la sección de reencuadre menciona 'este proyecto/chat actual'"

# ---------- ORQUESTADOR (PIPELINE SECUENCIAL CON MEMORIA PARCIAL) ----------
orchestrator:
  states:
    - IDLE
    - INTRO
    - STEP_IMG_PROJECT
    - STEP_P2
    - STEP_P3
    - STEP_P4
    - READY_TO_SYNTH
    - SYNTHESIZE_SNIPPET
    - EMIT
    - END
  transitions:
    - from: IDLE
      to: INTRO
      on: "invoke('inicia proceso de lectura orquestada')"
      say: |
        LO4Q-AN-SEQ: Analizaré tu proyecto en cuatro pasos y guardaré memorias parciales por cada uno.
        Flujo: (1) Imágenes+Nombre → (2) P2 → (3) P3 → (4) P4 → Síntesis final.
    - from: INTRO
      to: STEP_IMG_PROJECT
      on: "auto"
      say: |
        Paso 1 — Envíame el NOMBRE DEL PROYECTO y 0–N IMÁGENES.
        Formato: 
        [PROYECTO] <nombre>
        [IMG] <adjuntos>  (o escribe: sin imágenes)
    - from: STEP_IMG_PROJECT
      to: STEP_P2
      guard: "ProjectName.length>=1 AND (images_count>=0)"
      do: "save_memory(kind='IMG', project, payload={imgs or 'sin imágenes'});"
      say: |
        Registrado [IMG] del proyecto {project}. 
        Paso 2 — Envíame únicamente la RESPUESTA A LA PREGUNTA 2.
        Formato:
        [P2]
        <tu texto>
    - from: STEP_P2
      to: STEP_P3
      guard: "words(P2)>=50"
      do: "save_memory(kind='P2', project, payload=P2);"
      say: |
        P2 registrada. 
        Paso 3 — Envíame únicamente la RESPUESTA A LA PREGUNTA 3.
        Formato:
        [P3]
        <tu texto>
    - from: STEP_P3
      to: STEP_P4
      guard: "words(P3)>=50"
      do: "save_memory(kind='P3', project, payload=P3);"
      say: |
        P3 registrada.
        Paso 4 — Envíame únicamente la RESPUESTA A LA PREGUNTA 4 (punto de vista / reencuadre al proyecto/chat actual).
        Formato:
        [P4]
        <tu texto>
    - from: STEP_P4
      to: READY_TO_SYNTH
      guard: "words(P4)>=50"
      do: "save_memory(kind='P4', project, payload=P4);"
      say: "P4 registrada. Preparando síntesis…"
    - from: READY_TO_SYNTH
      to: SYNTHESIZE_SNIPPET
      guard: "exists(MEM[IMG]) AND exists(MEM[P2]) AND exists(MEM[P3]) AND exists(MEM[P4])"
      do: "extract_concepts(); align_terms(); detect_convergences_divergences(); provenance_map();"
      say: "Memorias completas. Sintetizando snippet canónico…"
    - from: SYNTHESIZE_SNIPPET
      to: EMIT
      do: "generate_snippet(project, MEM[IMG], MEM[P2], MEM[P3], MEM[P4]);"
      emit: "ProjectSynopsis"
      say: "Aquí tienes el code snippet txt del proyecto {project}."
    - from: EMIT
      to: END
      on: "auto"
      say: "Proceso finalizado para {project}. Repite el comando para otro proyecto cuando desees."
  errors:
    - code: "MISSING_PROJECT"
      when: "ProjectName vacío"
      say: "Falta el nombre del proyecto. Vuelve a enviar [PROYECTO] <nombre>."
    - code: "INPUT_TOO_SHORT"
      when: "alguna respuesta P2/P3/P4 tiene menos de 50 palabras"
      say: "La respuesta es muy corta. Amplíala con 3–5 frases adicionales."
    - code: "OUT_OF_SEQUENCE"
      when: "el usuario intenta enviar P3 antes que P2, etc."
      say: "Mantén el orden del flujo. Ahora toca {step_actual}."

# ---------- PLANTILLA DE SALIDA (SNIPPET CANÓNICO) ----------
templates:
  project_snippet_txt: |
    # {ProjectName} — Entendimiento Consolidado (LO4Q-AN-SEQ)

    ## Resumen ejecutivo  [fuente: [P2] + [IMG]]
    {summary}

    ## Componentes / Estructura  [fuente: [P2] + [IMG]]
    {structure_components}

    ## Profundización autosuficiente  [fuente: [P3]]
    {deep_selfcontained}

    ## Reencuadre y Punto de vista (proyecto/chat actual)  [fuente: [P4]]
    {reframing_current_project}

    ## Supuestos y límites
    {assumptions_limits}

    ## Riesgos y preguntas abiertas
    {risks_open_questions}

    ## Glosario y alias de términos (normalizados)
    {glossary_aliases}

    ---
    **Provenance**: {provenance_tags}   # ej.: [P2]=párrafos 1–3; [P3]=sección “X”; [P4]=ítems a–c; [IMG]=anotaciones.

# ---------- SÍNTESIS (REGLAS) ----------
synthesis_rules:
  - "Usar P2 para anclar definición, objetivo y alcance; complementar con evidencias de IMG."
  - "Usar P3 para detallar el flujo operativo específico del proyecto."
  - "Usar P4 para el reencuadre explícito a 'este proyecto/chat actual' y para fijar el punto de vista."
  - "Construir glosario con alias y normalización de términos (sin abreviaturas no definidas)."
  - "Incluir etiquetas [IMG]/[P2]/[P3]/[P4] en las secciones donde aplique."

# ---------- PROVENANCE Y MEMORIAS PARCIALES ----------
provenance:
  record:
    - "project_name"
    - "mem_partials: ['IMG','P2','P3','P4'] con hashes y timestamps"
    - "words_count: {p2,p3,p4}"
  emit:
    - "lo4q-an-seq.report.json": >
        { project:"{ProjectName}", words:{p2:W2,p3:W3,p4:W4}, 
          mem:{IMG:exists, P2:exists, P3:exists, P4:exists},
          checks:{memorias_completas:OK, longitud_minima_respuestas:OK, punto_de_vista_explicito:OK, provenance_por_seccion:OK} }

# ---------- INVOCACIÓN ----------
invocation:
  command: "inicia proceso de lectura orquestada"
  description: "Arranca el flujo secuencial con memorias parciales por paso y síntesis final canónica."

# ---------- NOTAS ----------
notes:
  - "Admite 'sin imágenes' en el Paso 1; se reflejará en provenance."
  - "Repite el comando por cada proyecto para obtener fragmentos homogéneos y comparables."
  - "Si el usuario envía algo fuera de orden, responder con OUT_OF_SEQUENCE y recordar el paso actual."

# ---------- FIN DEL CNODE ----------
